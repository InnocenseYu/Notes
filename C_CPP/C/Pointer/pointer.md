## 指针

### 指针的定义与使用
- 取变量地址使用&符号
- 定义指针变量时，使用 *var，说明: 该var变量是指针变量，不是普通变量，var赋值的内容是变量地址；
- 使用指针变量时，*var表示：读取var所保存变量地址指向的存储空间内容；

```C
取变量地址使用&符号
定义指针变量时，使用 *var，说明: 该var变量是指针变量，不是普通变量，var赋值的内容是变量地址；
使用指针变量时，*var表示：读取var所保存变量地址指向的存储空间内容；
```
![](./pointer_define.png)

### 指针变量详解
- 指针变量类型：自身的类型、指向的类型
- 自身的类型：在指针变量定义的时候，将变量名涂黑，剩下啥类型 指针变量就是啥类型

```
int *p,自身类型是int *
```
- 指向的类型：在指针定义的时候，将变量名和离他最近的*一起涂黑，剩下啥类型，指针变量指向的类型就是啥类型
```
  int ***p，自身类型是int ***,指向类型是int **
   作用：决定了指针变量+1跳过的单位跨度；
        决定了指针变量所取存储空间内容的宽度；
 ```
```C
e.g.
           1、char *p, p指向char类型，因为char类型是1byte,则p+1跳过单位跨度为1byte
            
           2、int num = 0x44332211;
              char *p = &num //char *p; p = &num;
              printf("*p = %#x\n",*p); //输出结果为*p = 0x11
              *p = 0;
              printf("*p = %#x\n",*p);   //输出结果为*p = 0x00
              printf("num = %#x\n",num); //输出结果为num = 0x44332200,因为char *p指向类型是
                                         //char是一个字节，且*p代表所存变量地址指向存储空间的内
                                         //容，通过指针p的指向类型char操作*p代表所存变量地址指向
                                         //存储空间的内容，且只能操作一个字节
```
![](./pointer_variable.png)

```C
连续读取0x03 0x02，

定义p5指针变量char 1个字节类型，每次+1可以取一个，p5+1取值为0x03,使用*(short *)p5 强制转换，此时p5指向类型为short 两个字节，进而读出0x03 0x02
```
![](./pointer_variable1.png)

### 野指针
- 指针未初始化
![](./pointer_NoInitialize.png)
- 解决方法：
  - 当不知道初始化什么值时，可以使用NULL
  - ![](./pointer_NoInitialize1.png)
- 指针越界访问
  - ![](./pointer_NoInitialize2.png)
- 指针指向的空间释放
```C
示例：test()函数作用完后将地址指向的空间释放，当前p=20的操作，虽然指向地址没变，但是指向地址的空间已经不是test()函数作用的空间了
```
  - ![](./pointer_NoInitialize3.png)

### 指针使用-注意事项
- 使用之前检查有效性
- 初次使用时，正确初始化
- 暂时不使用时，赋值NULL
- 再次使用时，使用if语句判断后再进行操作

### 指针 + - 整数
- 指针p++表示p = p+1
- 指针p+=1也表示p = p+1
- 指针p+=2 表示p = p+2
- p-=2也是同理
- ![](./pointer_operator.png)
- ![](./pointer_operator1.png)

### 指针 - 指针
- 指向同一个内存空间的两个指针相减，得到的结果是两个指针之间的元素个数，下图中//err注释部分即为错误写法
- ![](2022-05-05-00-38-44.png)

### 指针的关系运算

![](./pointer_compare1.png)

![](./pointer_compare2.png)

以上两种代码方式，优先选择第一种，实际在绝大部分的编译器上是可以顺利完成任务的，然而我们还是应该避免这样写，因为第二种写法C标准并不保证它可行。

- 标准规定：
允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较

![](./pointer_compare3.png)

### 数组指针
- 区分[指针数组](../Array/array.md/#指针数组)
- 差异：
  - 指针：存放一个地址，或者数组中某个元素的地址，或者数组名代表的数组首地址
  - 数组：一类元素的集合

- 数组名是首元素地址
- 是首元素地址有两个例外
  - sizeof(arr)不行，arr表示整个数组，计算的是整个数组（数组中所有元素的集合）存储空间的大小，单位字节；
  - &arr不行，arr表示整个数组，取出的是整个数组的地址
  - 
  - 虽然arr &arr[0] &arr 内存地址相同，但是&arr取出的是整个数组的起始地址，&arr+1表示的是数组中最后一个元素后一个元素的地址，如下图
  - 除了以上两种情况以外，所有的数组名都表示数组首元素的地址；

![](../Array/array_name1.png)
![](../Array/array_name2.png)

### 二级指针
- 指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？这就是二级指针
- 每级指针通过读取地址，依次访问地址对应的上级的值

![](./sec_grade_pointer.png)