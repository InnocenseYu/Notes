## 存储


### 变量的定义（关键字修饰）
- int 的原型是 signed int, 一般不写signed，是有符号整型
- 无符号整型 unsigned int a = 2; 
- char 类型一个字节8bit,也可以被singed unsigned 关键字修饰
- 局部变量 auto int a=2; auto 一般默认不写；
- 寄存器变量 register int a=2; 因寄存器数量有限，建议定义，一般不定义，定义后具体是否使用看编译器；
- 短整型 short int a = 2; a 至少2个字节长度，不大于int,一般只写short a = 2;即可
- 长整型 long int a =2;不小于int 长度，至少4个字节长度，一般写作 long a = 2;即可
- 类型定义 typedef 关键字
  - 类型重命名
  - 使用方法：typedef 类型定义 类型重定义
    - typedef unsigned int u_int;
    - e.g: unsigned int a = 10;等价于 u_int a = 10;

### 宏定义
- #define MAX(X,Y) (X>Y?X:Y)
- 使用 MAX(X,Y) 替换 (X>Y?X:Y)

### 结构体
- 定义方式：
  - struct 标记/结构名 { }; 
    - 声明结构
    - 可以多次使用标记定义 结构变量
  - struct 标记/结构名 { } 结构变量；
    - 声明结构 和 定义结构变量 一起使用
  - struct 标记/结构名 结构变量;
  - struct 标记/结构名* 结构变量;
    - 定义结构体指针，结构变量自身类型为 struct 标记/结构名*，指向类型为 struct 标记/结构名
  - struct { } 结构变量; 
    - 当声明结构 和 定义结构变量 合并一起的话，可以不需要使用标记/结构名
    - 因为无 标记/结构名，所以只能定义一次结构变量
  - struct 标记/结构名 结构变量 = { }; 
    - 结构体初始化
- 结构变量成员操作
  - 结构体变量 b1.成员 访问内部
  - 结构体指针变量pb->成员 访问内部
  - 对成员是""包裹、字符数组类型，使用strspy()函数操作，不能类似其他数组使用下标操作

### 变量生命周期

- 变量的生命周期：指的是变量的创建到变量的销毁之间的一个时间段
- 局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束
- 全局变量的生命周期是：整个程序的生命周期

### 变量、作用域

- 局部变量（函数内部、代码块{}内部使用的变量）的作用域是变量所在的区域的局部范围，如{}内部定义并使用的变量，出{}后作用域失效；
- 局部变量默认都是自动变量，如: auto int a = 10; 一般不写auto关键字

- static（翻译：静态的）关键字，修饰局部变量，改变了局部变量的生命周期，本质上是改变了变量的存储类型，从栈区到静态区
- static 修饰全局变量，使得这个**全局变量**只能在自己所在的源文件.c内部可以使用，其他源文件**不能**使用
- static 修饰函数，改变了函数的链接属性，使得函数具有的外部链接属性被修改为内部链接属性，只能在自己所在的源文件内部使用，不能在其他源文件内部使用
- static 修饰全局变量和函数，本质上：static 是将全局变量和函数的外部链接属性变成了内部链接属性

- 全局变量（函数内部、代码块{}外部使用的变量）的作用域可在使用前通过 extern（翻译：外部的）关键字声明，作用于整个工程中的任意一个 .c 源文件
  - 全局变量，在其他源文件内部通过 extern 关键字声明可以被使用，是因为全局变量具有外部链接属性
  - 但是被 static 修饰之后，就变成了内部链接属性，其他源文件就不能链接到这个静态的全局变量了

- 全局变量定义后，再次被局部变量定义的话，局部变量优先使用
- **区分 static 修饰局部变量是改变生命周期，修饰全部变量和函数是改变外部链接属性为内部链接属性**

![](./stack0.png)


### 栈区的使用

- 函数中局部变量i、arr都是局部变量，局部变量值都存储在栈区上
- 函数中 形参 也是存储在栈区
- 函数调用也是在栈区申请空间
- 栈区空间的使用：
  - 先使用栈区高地址处的空间再使用低地址处的空间
  - 栈区存储数组的话，也尊寻随着下标的增长地址是由低到高变化
- 数组如果合适的往后越界的话，就有可能在越界的过程中遇到i或者其他局部变量；
- 当改变数组元素时，就有可能改变i或者其他局部变量的值，出现死循环或者其他奇怪的问题
- 栈区被使用完后就会抛出错误，StackOverflow 栈溢出
- 不同编译平台，相邻的两个局部变量存储地址间隔不同
  - linux平台，gcc编译器：间隔一个地址
  - vc6.0 编译器：紧挨着无间隔
  - vs2013编译器：间隔两个地址

![](./stack.png)


### 计算机存储结构
- 寄存器关键字 register
- 因为cpu计算速度跟内存读写速度不匹配，在cpu和内存之间加入读取速度更快的高速缓存和寄存器
- 当为了高速访问变量时，可以将变量定义寄存器变量，如: register int a; 因为寄存器数量有限，只是**建议**这样定义，一般不定义

![](./register.png)

### 如何产生存储地址(假设32位系统，按字节byte进行编址)
- 内存 = 末地址 - 首地址 + 1
- 2^32二进制表示为 1*2^32，33个二进制数，由1个1和32个0组成，假设首地址是0，则末地址 = 内存 -1 = 2^32 -1,使用2进制计算得到首位一个0和32个1，16进制表示则为0xffffffff
- 32根地址线，每根地址线有0,1两种状态代表电平高低，二进制数 从 000...000(32位) 到 111...111(32位) ，一共有2^32个存储地址,范围从0-0xffffffff
- 每个地址（按字节进行编址）表示一个存储单元的位置，所以存储单元的个数也为2^32个
- 存储容量 = 存储单元 * 8bit

### 整数在计算机内存中存储形式

[二进制整数原码 反码 补码 运算](./../Operator/operators.md/#整数在计算机内存中存储形式)