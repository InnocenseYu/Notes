## 存储


### 变量类型
- 类型的意义
  - 使用该类型开辟空间的大小；
  - 如何看待内存空间的视角
- 整型
  - int 的原型是 signed int, 一般不写signed 默认是有符号整型, 32位系统 int 大小 4byte
  - 无符号整型 unsigned int a = 2; 
  - char 类型1byte 8bit, 也可以被singed, unsigned 关键字修饰
  - 短整型 short int a = 2; a 至少2个字节长度，不大于int, 也可以被singed, unsigned 关键字修饰，signed short int a = 2; 一般只写short a = 2; 即可，32位系统short 大小 2byte
  - 长整型 long int a =2;不小于int 长度，至少4个字节长度，也可以被singed, unsigned 关键字修饰，signed long int a = 2; 一般只写 long a = 2;即可
  - 局部变量 auto int a=2; auto 一般默认不写；
  - 寄存器变量 register int a=2; 因寄存器数量有限，建议定义，一般不定义，定义后具体是否使用看编译器；
  
- 浮点型
  - fload 大小 4byte, 单精度浮点型
  - double 大小 8byte, 双精度浮点型

- 构造类型
  - 数组类型
  - 结构体类型 struct
  - 枚举类型 enum
  - 联合类型 union
- 指针类型
  - void* fun
  - int* p
  - char* p
  - float* p
- 空类型 无返回值
  - void: 函数返回类型
    - void func()
  - 函数的参数
    - void func(void)

### 类型重命名: typedef 关键字
- 使用方法：typedef 类型定义 类型重定义
  - typedef unsigned int u_int;
  - e.g: unsigned int a = 10;等价于 u_int a = 10;

### 宏定义
- #define MAX(X,Y) (X>Y?X:Y)
- 使用 MAX(X,Y) 替换 (X>Y?X:Y)

### 变量生命周期

- 变量的生命周期：指的是变量的创建到变量的销毁之间的一个时间段
- 局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束
- 全局变量的生命周期是：整个程序的生命周期

### 变量、作用域 static extern

- 局部变量（函数内部、代码块{}内部使用的变量）的作用域是变量所在的区域的局部范围，如{}内部定义并使用的变量，出{}后作用域失效；
- 局部变量默认都是自动变量，如: auto int a = 10; 一般不写auto关键字

- static（翻译：静态的）关键字，修饰局部变量，改变了局部变量的生命周期，本质上是改变了变量的存储类型，从栈区到静态区
- static 修饰全局变量，使得这个**全局变量**只能在自己所在的源文件.c内部可以使用，其他源文件**不能**使用
- static 修饰函数，改变了函数的链接属性，使得函数具有的外部链接属性被修改为内部链接属性，只能在自己所在的源文件内部使用，不能在其他源文件内部使用
- static 修饰全局变量和函数，本质上：static 是将全局变量和函数的外部链接属性变成了内部链接属性

- 全局变量（函数内部、代码块{}外部使用的变量）的作用域可在使用前通过 **extern**（翻译：外部的）关键字声明，作用于整个工程中的任意一个 .c 源文件
  - 全局变量，在其他源文件内部通过 extern 关键字声明可以被使用，是因为全局变量具有外部链接属性
  - 但是被 static 修饰之后，就变成了内部链接属性，其他源文件就不能链接到这个静态的全局变量了
  - 全局变量不初始化，默认是0；

- 全局变量定义后，再次被局部变量定义的话，局部变量优先使用
- **区分 static 修饰局部变量是改变生命周期，修饰全部变量和函数是改变外部链接属性为内部链接属性**

![](./stack0.png)


### 栈区的使用

- 函数中局部变量i、arr都是局部变量，局部变量值都存储在栈区上
- 函数中 形参 也是存储在栈区
- 函数调用也是在栈区申请空间
  - 当函数传入的参数不是地址时，形参需要对实参一份临时拷贝，因为临时变量存储在栈区，栈区增加元素只能从顶上增加，所以形参对实参一份临时拷贝是压栈操作
- 栈区空间的使用：
  - 栈区插入元素，只能从顶上增加 - 压栈，顶上删除元素 - 出栈
    - 所以先进的后出，后进的先出
  - 先使用栈区高地址处的空间再使用低地址处的空间
  - 栈区存储数组的话，也尊寻随着下标的增长地址是由低到高变化
- 数组如果合适的往后越界的话，就有可能在越界的过程中遇到i或者其他局部变量；
- 当改变数组元素时，就有可能改变i或者其他局部变量的值，出现死循环或者其他奇怪的问题
- 栈区被使用完后就会抛出错误，StackOverflow 栈溢出
- 不同编译平台，相邻的两个局部变量存储地址间隔不同
  - linux平台，gcc编译器：间隔一个地址
  - vc6.0 编译器：紧挨着无间隔
  - vs2013编译器：间隔两个地址

![](./stack.png)


### 计算机存储结构
- 寄存器关键字 register
- 因为cpu计算速度跟内存读写速度不匹配，在cpu和内存之间加入读取速度更快的高速缓存和寄存器
- 当为了高速访问变量时，可以将变量定义寄存器变量，如: register int a; 因为寄存器数量有限，只是**建议**这样定义，一般不定义

![](./register.png)

### 如何产生存储地址(假设32位系统，按字节byte进行编址)
- 地址是连续的
- 内存 = 末地址 - 首地址 + 1
- 2^32二进制表示为 1*2^32，33个二进制数，由1个1和32个0组成，假设首地址是0，则末地址 = 内存 -1 = 2^32 -1,使用2进制计算得到首位一个0和32个1，16进制表示则为0xffffffff
- 32根地址线，每根地址线有0,1两种状态代表电平高低，二进制数 从 000...000(32位) 到 111...111(32位) ，一共有2^32个存储地址,范围从0-0xffffffff
- 每个地址（按字节进行编址）表示一个存储单元的位置，所以存储单元的个数也为2^32个
- 存储容量 = 存储单元 * 8bit

### 整数在计算机内存中存储形式

[二进制整数原码 反码 补码 运算](./../Operator/operators.md/#整数在计算机内存中存储形式)

### 存储的大小端问题（讨论字节顺序的问题）
- 小端（存储）模式，指数据的低位，保存在内存的低地址中， 而数据的高位，保存在内存的高地址中
- 大端（存储）模式，指数据的低位，保存在内存的高地址中， 而数据的高位，保存在内存的低地址中
  - 数据低位：当整形数据为 0x11223344, 0x44即为数据低位，0x11为数据高位
  - 低地址：当 0x000000c8 为一地址，0x000000c8 即为低地址，因为地址是连续的，后续为0x000000c9 0x000000ca 0x000000cb...
```C

// 1byte 8bit 数据占一个内存地址, 假设整形数据 0x11223344，内存指向地址为0x000000c8
// 小端（存储）模式：
// 0x000000c8 0x44
// 0x000000c9 0x33
// 0x000000ca 0x22
// 0x000000cb 0x11

```
- 我们常用的 X86 架构小端模式，而KEIL C51 则为大端模式。
- 很多的ARM，DSP都为小端模式。
- 有些ARM处理器还可以由硬件来选择是大端模式还是小端模式

### 变量类型强制转换

- [指针类型的意义](../Pointer/pointer.md/#指针类型的意义)

```C

void srand(unsigned seed);    //seed 必须是时刻变化的量，unsigned类型，可以使用时间戳代替，使用time函数获取时间戳

time_t time(time_t* const timer);  //函数包含在 time.h,time函数返回值类型是time_t，右键查看定义，time_t类型是使用typedef 重命名的long型

srand((unsigned) time(NULL));  //调用一次即可
//time函数返回值类型与srand函数输入参数类型不同，强制转换,类型使用括号包裹；
//time函数输如参数为指针类型，防止空指针，初始化为NULL
```

![](../Pointer/pointer_variable.png)

```C
连续读取0x03 0x02，

char* p5 = &num; // num = 0x01020304; p5 存放num的地址，*p5 = 0x01020304；小端存放形式为04030201
p5++; // 地址每加1向右移动一个字节；指向03的地址
p5 = (short*) p5; //将 p5, char类型指针强制转换为指向类型为short两个字节且自身类型为short*的类型；起始地址指向03的地址
printf("*p5 = %#x\n", *p5); //起始地址指向03的地址，1次读取一个short 长度的值，读取的结果为 0302，从小端存储 打印出来是0x0203

//定义p5指针变量char 1个字节类型，char* p5, 每次+1可以取一个，p5+1 地址指向0x03值的地址, 使用*(short*)p5 将p5强制转换为指向类型为short 两个字节，自身类型为short*的类型，进而读出0x03 0x02
```
![](../Pointer/pointer_variable1.png)


### 类型强制转换 操作过程

- arr数组地址及其存储的值

![arr数组地址及其存储的值](../Pointer/force_switch.png)

- p指针地址指向arr数组的地址，第一次操作，01变为00

![p指针地址指向arr数组的地址，第一次操作](../Pointer/force_switch1.png)

- p指针地址指向arr数组的地址，第三次操作,02变为00

![p指针地址指向arr数组的地址，第三次操作](../Pointer/force_switch2.png)

```C

int main()
{
	int arr[] = { 1, 2, 3, 4, 5 }; // arr数组地址即为首元素地址 0x005ffe68, arr[0] 用16进制表示, 小端存储, 为0x01000000, 4个字节
	                               // arr[1]内存地址为 0x005ffe6b, arr[1] = 0x02000000,
	short* p = (short*)arr; //强制转换为 short*类型指针, p指针存储 short 类型 arr 数组地址0x005ffe68, 在该地址上操作存储的值
	int i = 0;
	for (i = 0; i < 4; i++)  
	{
		*(p + i) = 0; //i = 0, 第一次操作arr[0] 中0100；
                      //i = 1, 第二次操作arr[0] 中0000；
                      //i = 2, 第三次操作arr[1] 中0200
	}

	for (i = 0; i < 5; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}

```

### 整型提升/隐式转化
- [整型提升/隐式转化](../Operator/operators.md/#整形提升隐式转换)

```C

int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	// c 二进制 -1
	// 10000000000000000000000000000001 原码
	// 11111111111111111111111111111110 反码
	// 11111111111111111111111111111111 补码
	// 整型截断
	// unsigned char c 11111111
	printf("a=%d,b=%d,c=%d", a, b, c);
	// c = %d
	// 1, 整型提升 unsigned char -> int 
	// 11111111 -> 00000000000000000000000011111111 补码
	// 2, 补码 -> 原码 转换
	// %d 有符号十进制 输出，根据补码的符号位进行 补码 -> 原码 转换，输出原码


int main()
{
	char a = -128;
	// a       10000000000000000000000010000000 原码
	//         11111111111111111111111101111111 反码
	//         11111111111111111111111110000000 补码
	// 整型截断 char a  10000000
	printf("%u\n", a);
	// 1, 整型提升 char -> int 
	// 10000000 -> 11111111111111111111111110000000 补码
	// 2, 补码 -> 原码 转换
	// %d 有符号十进制整型 输出，正常是根据补码的符号位进行 补码 -> 原码 转换，输出原码，
	// 但是 %u 无符号十进制整型 输出的话，默认整型提升后的补码最高位不是符号位，是无符号数，原码 反码 补码 三码相同，无需转换
	// 3, 无符号二进制 -> 十进制 
	// 11111111111111111111111110000000 -> 4294967168
	return 0;
}

```