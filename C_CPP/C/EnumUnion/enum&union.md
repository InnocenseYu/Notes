## 枚举

### 枚举定义

- 枚举是一种类型;
- 把可能的取值一 一列举
- 枚举列表中的 枚举常量 不是枚举成员，是用 , 逗号 隔开的，与数组大括号内的值相似, 使用 ，隔开各个值，末尾的值不使用符号
- 枚举类型，指一个被命名的整型常数的集合，每个整型常数是枚举类型。本质上是一组常数的集合体，只是这些常数有各自的命名
  - sizeof(enum Sex) == 4byte
- 枚举变量的赋值只能使用枚举列表中的 枚举常量 来赋值
- 枚举常量 无初始值时， 默认 第一个 起始值为0，往后每个 +1；
- 对枚举常量 赋初始值时， 第一个枚举常量的值不受 其他枚举常量的影响，无初值时为0，有初值时即为初值

```C

enum Sex
{
    // 以下为枚举的可能取值，称为 枚举常量
    MALE, // 注意是 逗号 , 结尾
    FEMALE,
    SECRET // 无符号结尾
};

enum Sex s1 = MALE; // 全局枚举变量 s1, 赋值的话只能使用 Sex 枚举列表中的成员 枚举常量 来赋值

enum Color
{
    RED = 2, // 枚举常量的初始化，
    GREEN,
    BLUE
};

int main()
{
    enum Sex s2 = SECRET; // 局部变量 s2
    enum Color c = RED;
    printf("sizeof(enum Color) = %d\n", sizeof(enum Color)); // 4byte
    printf("sizeof(c) = %d\n", sizeof(c)); // 4byte

    printf("%d %d %d\n", RED, GREEN, BLUE); // 0 1 2

    return 0;
}

```

### 枚举的优点
- 相对于 #define 定义常量，为什么非要使用枚举
  - 增加代码的可维护性和可读性
  - 枚举的变量是枚举类型，是类型就有类型检查，比#define 的预处理 更加严谨
  - 防止命名污染（封装）？
  - 便于调试
  - 使用方便，一次可以定义多个常量(枚举常量是有值的)


## 联合体(共用体)

### 联合的含义
- 联合体各成员公用同一块内存空间，无论各成员的类型大小
- 各成员的内存地址同联合体成员的地址一致

### 联合体大小计算
- 一个联合变量的大小，至少是 **最大成员类型的大小**（因为联合至少得有能力保存最大的那个成员，数组是按照数组元素的大小看的）
- 当**最大成员大小**不是**最大对齐数**的整数倍的时候，就要对齐到**最大对齐数**的整数倍

```C

union Un
{
    char c; // c 大小为 1byte
    int b; // b 大小为 4byte
    char a[5]; // a 大小为 5byte, 对齐数max(1,8) = 8; 5不是8的整数倍，则对齐的是8的整数倍，1*8 = 8；
                                            // min() 中8为平台默认对齐数，可以参考 结构体对齐
};

union Un u;
// sizeof(u) == sizeof(union Un) == 8 byte. 对齐到最大对齐数 8 的整数倍

printf("%p\n", &u);
printf("%p\n", &(u.c));
printf("%p\n", &(u.b));
// 以上三个printf 打印的地址相同

```