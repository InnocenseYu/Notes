## 编译原理


### 编译中间文件后缀格式
```

*.c  　——C源文件
*.i  　——经过预处理后的C源文件
*.o　  ——汇编代码转换成计算机可认识的二进制文件
*.h  　——C头文件
*.ii  　——经过预处理后的C++源文件
*.cc　　——C++源文件
*.cxx  ——C++源文件
*.cpp  ——C++源文件
*.C  　——C++源文件
*.s  　——不需要预处理的汇编文件
*.S  　——需要预处理的汇编文件

```

### 命令格式

> gcc [options] file…
> 
> 在命令 gcc 后面跟一个或多个选项，选项间用空格隔开，然后跟一个或多个目标文件

### 输出控制选项

> -c　　　　　将输入的源文件编译成目标文件 / 对目标文件执行指令转换
> 
> -S　　　　　将C/C++文件生成汇编文件
> 
> -o file　　　将输出内容存于文件file
> 
> -pipe   　　　在编译的不同阶段之间采用管道通讯方式
> 
> -v　　　　　打印出编译过程中执行的命令
> 
> -x language　说明文件的输入类型为language


### GNU GCC 的基本功能

1. 预编译 (Preprocessing)
2. 编译 (Compilation)
3. 汇编 (Assembly) 
4. 链接 (Linking/Build)
5. 程序运行

### 预处理选项
> -E    　　　　运行C的预处理器
> 
> -C    　　　　在运用-E进行预处理时不去掉注释
>
> -D macro    　定义宏macro为1
>
> -D macro=defn  　　定义宏macro为defn

### 预编译 (Preprocessing)
- gcc 命令 是编译的前端程序，它通过调用其他程序来实现将程序源文件编译成目标文件的功能

- 预编译：首先调用预处理程序 cpp 对输入的源程序进行处理，处理各种预处理指令（#include、#define、#ifdef 等 #开始的代码行），删除注释和多余的空白字符，生成一份新的代码
- 如展开头文件，对 #include 包含的头文件内容做一个简单的替换，替换到.c 文件里面去
- 把代码中的注释去掉
- 替换 #define 定义的宏
- 最终输出预处理后的 C/C++ 源程序

#### 操作指令

> 将 hello.c 源文件使用预处理器处理后的源程序输出内容存到文件 hello.i
> 
>gcc -E -o hello.i hello.c
>
>gcc 对目标文件 hello.c 运行 C 的预处理(-E)
>
> 注意：-o 作用是指定输出文件的名字，如果不加 - o 的话，则生成的文件名字总叫 a.out


### 编译 (Compilation)

- 调用 cc1 程序对预处理后的源程序代码进行语法、语义分析和错误判断，输出 C/C++ 源程序的汇编代码

#### 操作指令
> gcc -S -o hello.s hello.i
> 
> gcc 对目标文件 hello.i 进行编译(-S)，生成汇编文件输出内容到 hello.s 文件，.s 后缀的文件不需要再次预处理了

### 汇编 (Assembly) 

- 把汇编代码转换成计算机可认识的二进制文件输出
  - 调用 as 汇编器程序，将汇编语言程序转换为 ELF (Executable and Linking Format，执行时链接文件格式) 格式的可重定位目标代码，这些目标代码同其它目标模块或函数库易于定位和链接
  - as 汇编器程序产生一个交叉参考表和一个标准的符号表，产生的代码和数据能够放在多个区 (Section) 中
- 可以通过以下方法将二进制文件 hello.o 转化为我们可读的形式
  - readelf -a hello.o

#### 操作指令
> gcc -c -o hello.o hello.s
> 
> gcc 对目标文件 hello.s 执行指令转换（-c），生成汇编文件输出内容到 hello.s 文件


### 链接 (Linking/Build)

- 通俗的讲就是把一个或多个 *.o 二进制指令文件合并成一个可执行文件
  - ld 链接器程序根据链接定位文件 Linkcmds 中的代码区、数据区、BSS 区和栈区等定位信息，将可重定位的目标模块链接成一个单一的、绝对定位的目标程序
  - 该目标程序是 ELF 格式，并且可以包含调试信息。

  - ld 链接器程序会产生一个内存映象文件 Map.txt, 该文件显示所有目标模块、区和符号的绝对定位地址。它也产生交叉参考列表，显示参考每个全局符号的目标模块。

  - ld 支持将多个目标模块链接成一个单一的、绝对定位的目标程序，也能够依此对目标模块进行链接，这个特性称为增量链接 (Incremental Linking)。

  - 假如输入文件是一个函数库，ld 会自动从函数库装载被其它目标模块参考的函数模块。ld 与其它链接程序相比，能提供更有帮助的诊断信息。许多链接器遇到第一个错误即放弃链接，而 ld 只要有可能都继续执行，帮助用户识别其它错误，有时甚至能获得输出代码
- 可以对合并成的可执行目标程序文件进行**二进制指令转汇编**操作
  - objdump -d hello

#### 操作指令

> gcc -o hello hello.o  
> 
> 注意：gcc  **没有单独的链接参数**, 将系统库函数与 hello.o 进行链接，得到可执行的程序，该程序的名字叫 hello

### 程序运行

- ./ 当前文件夹，否则系统到系统源文件中查找
- ./hello 即可执行最终生成的可执行文件

- 如果想知道在 linux 系统下链接来了什么库（即可执行程序需要用到什么库），使用命令 ldd hello 查看

### 生成静态库

- ar 库管理程序 将多个可重定位的目标模块归档为一个函数库文件。采用函数库文件，应用程序能够从该文件中自动装载要参考的函数模块，同时将应用程序中频繁调用的函数放入函数库文件中，易于应用程序的开发管理。ar 支持 ELF 格式的函数库文件
- 编译静态库，后缀为 .a
  - ar rcs libxx.a  fun.c


- 生成可执行程序
- 转换文件格式
