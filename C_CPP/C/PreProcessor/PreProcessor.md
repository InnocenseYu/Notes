## 目录

[toc]

## 程序编译过程

### 翻译环境

- 定义：.c 源文件通过一系列 预处理、编译、链接等操作 生产 .exe (Windows下)可执行程序的过程；

### 运行环境

- 定义：可执行程序运行需要的一系列操作



![image-20220822014825401](image-20220822014825401.png)



#### 编译器

- 组成一个工程程序的每个源文件通过编译过程都会分别转换成目标代码

#### 链接器

- 链接器同时也会引入标准C函数库中**任何被该程序所用到的函数**，而且它可以搜索程序员**个人的程序库**，将其需要的函数也链接到程序中；
- 链接器（linker）将每个目标文件捆绑在一起，结合 标准C函数库 中**任何被该程序所用到的函数**和程序员**个人的程序库**形成一个单一而完整的可执行程序



### 预处理语法

#### 预定义符号

- C 自身内部已经预定义的符号

```C
printf("%s\n", __FILE__); // 当前源文件在系统中的绝对路径地址
printf("%d\n",__LINE__);  // 本段代码所在的行号
printf("%s\n",__DATE__);  // 当前日期 月日年
printf("%s\n",__TIME__);  // 当前时间 时分秒
printf("%s\n",__FUNCTION__);  // 当前 函数名

__STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义
printf("%d\n",__STDC__);
```



### 预处理指令

- #开头的指令都是预处理指令

```c
#define
#include

// 其他
#if
#endif
#ifdef
#line
#pragma pack(4)
#pragma
```



#### #define

- 定义标识符

  - ```c
    #define name stuff // stuff 可以是多种格式
    // #define MAX 100
    // #define STR "haha"
    // #define CASE break;case // 写 CASE 语句的时候自动把 关键字 break带上
    // #define do_forever for(;;)
    
    // 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
    // #define DEBUG_PRINT printf("file:%s\t \
                                   line:%d\t \
                                   date:%s\t \
    							   time:%s\n", \
    							   __FILE__,__LINE__, \
    							   __DATE__,__TIME__ )
       
    ```
  
  
  
- 定义宏: 使用宏的变量是对变量的完全替换，应该多使用()
  
	- 宏 **不能出现递归**
  
  - ```c
    #define SQUARE(X) X*X
    SQAURE(5+1); // 11; 
    // 5+1 * 5+1 = 11
    ```
  
    

#### # 和 \## ##

- 如何将参数插入到字符串中？

  - 使用# ，把一个宏参数变成对应的字符串

  - ```c
    #define PRINT(VALUE) printf("the value of " #VALUE "is %d\n", VALUE)
    // #VALUE 相当于把 VALUE 强制变成 "VALUE" 字符串
    // int a = 3,b=4;
    // printf 函数中多个""包裹的字符串天然的会连在一起，当作一个字符串打印
    PRINT(a); // "the value of " "a" "is %d\n"，#VALUE 替换为 "a"，打印为：the value of a is 3
    PRINT(b); // "the value of " "b" "is %d\n"
    ```

- \## 可以把位于它两边的符号合成一个符号

  - 这样的连接必须产生一个合法的标识符。否则其结果就是未定义的

  - ```c
    #define CAT(X,Y) X##Y
    
    int main()
    {
        int nihao = 2022;
        // printf("%d\n",nihao);
        printf("%d\n",CAT(ni,hao));// 打印为2022
    }
    ```

  - 它允许宏定义从分离的文本片段创建标识符

  - ```c
    #define ADD_TO_SUM(num, value) sum##num += value;
    
    ADD_TO_SUM(5,10); // 给 sum5 增加10；
    ```


#### 带副作用的宏参数

- 当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。
- 副作用就是表达式求值的时候出现的永久性效果
- 注意：宏定义中的**运算参数是直接替换的**，**不是运算后才进行的替换**

```c
#define MAX(a, b) ( (a) > (b) ? (a) : (b) )

int a = 0;
int b = 1;
int c = MAX(a,b); // MAX(a++, b++) -> ((a++)>(b++)?(a++):(b++)), 0>1? c=b+1=1+1=2, b=1+1+1=3; a=0+1=1 
```

- b++ 并没有按照 （b+1）的形式给出结果，这就是宏的副作用



#### 宏与函数的对比

- 命名约定
  - 一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者
  - 那我们平时的一个习惯是：把**宏名全部大写**，**函数名不要全部大写**

- 优势

  - 宏操作的灵活性，比如函数参数的类型检查宏就没有，**宏是类型无关的**

    - ```C
      #define MALLOC(num, type)\
      	(type *)malloc(num * sizeof(type))
      
      //使用
      MALLOC(10, int);//类型作为参数
      ```

  - 宏操作更加高效，函数调用和返回有大量开销，比如源文件在预处理时宏的替换就比函数快，同时函数在预处理后还有其他调用和开销比宏大

- 略势

  - **每次**使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度，但是每次使用函数的时候，只是调用已经写好的程序
  - 宏是没法调试的，因为宏是对内容直接的替换，调试时无法针对宏进行调试
  - 宏可能会带来运算符优先级的副作用问题，导致容易出现错误



- 宏 模拟函数 offsetof 

```c
#define OFFSETOF(struct_name, struct_member) (int)&(((struct_name *)0)->struct_member)

// 这里 (int) 强制转换的意思是将地址强制转换为 int 型，参与 "地址 - 0" 的运算，并不是对地址的强制类型转换(int *)
```



#### #undef

- 移除一个已经存在的宏定义

- ```c
  #undef NAME
  //如果现存的一个 NAME 需要被重新定义，那么它的旧名字首先要被移除。
  ```

  

#### 条件编译

有选择性的编译指令

- 常量表达式

```c
// 常量表达式由预处理器求值
#if 常量表达式
	//... 
#endif

#if 1-1
	// 1-1=0 为假，不执行
	// 1>2 为假，不执行  
#endif
```

- 多个分支的条件编译

```c
#if 常量表达式
	// ...
#elif 常量表达式
	// ...
#else
	// ...
#endif
```

- 判断是否被定义

```c
#ifdef DEBUG
	// 上面已经定义 #define DEBUG
#endif
	或者
#if defined(DEBUG)
    // ...
#endif
        
------------------    
#ifndef DEBUG
	// ...
#endif
    或者
#if !defined(DEBUG)
	// ...
#endif
```

- 嵌套指令



#### 命令行编译

```c
#include <stdio.h>
int main()
{
    int array [ARRAY_SIZE];
    int i = 0;
    for(i = 0; i< ARRAY_SIZE; i ++)
    {
        array[i] = i;
    }
    
    return 0;
}
```

```shell
gcc -D ARRAY_SIZE=10 source.c
// ARRAY_SIZE=10 可以直接操作源文件中的 ARRAY_SIZE 参数大小
// 这步操作的实现是在预编译阶段进行的，将命令行参数替换到源文件中
```



#### 文件包含

- 使用包含的内容替换的方式很简单：

  - 预处理器先删除这条指令，并用包含文件的内容替换。

  - 如果这样一个源文件被包含10次，那就实际被编译10次，会造成代码的冗余，可以在对应函数的头文件中使用条件编译进行判断

    - ```c
      // 方法一 较老的写法，编译器兼容性好
      #ifndef __TEST_H__
      #define __TEST_H__
      	// ...
      	// 注意头文件全部大写，"."使用 "_" 代替
      #endif
      
      // 方法二 新写法
      #pragma once
      ```

    - 代码分析 **方法一**：当第一次调用 test.h 时，会定义 test.h，执行 #endif 之前的代码；再次碰到 test.h 时，不满足条件编译 #ifndef，则 #endif 前的代码不会执行

    - 代码分析 **方法二**：**目前通用写法**，但是较古老的编译器可能不识别

  

  - 本地文件包含

    - 查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。如果找不到就提示编译错误

    - ```c
      #include "filename.h" 
      ```

  - 标准库包含

    - 查找策略：查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。

    - ```c
      #include <filename.h>
      ```

    - 对于库文件也可以使用 “” 的形式包含？

      - 可以。但是**这样做查找的效率就低**些，当然这样也**不容易区分是库文件还是本地文件**了



#### 其他预处理指令 

- #error
- #pragma
- #line
- 参考[^1]
- ...



[返回顶部](#目录)

[^1]: 参考《C 语言深度剖析》
